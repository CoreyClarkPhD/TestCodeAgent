[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/d5tDVxWv)
[![Open in Codespaces](https://classroom.github.com/assets/launch-codespace-7f7980b617ed060a017424585567c406b6ee15c891e84e1186181d67ecf80aa0.svg)](https://classroom.github.com/open-in-codespaces?assignment_repo_id=13122778)


https://github.com/HuMIn-Game-Lab/final-autonomous-code-assistant-agent-drew-harris/assets/61394759/8c1074aa-113e-46ae-9d5e-eef2158df529


# Report

My autonomous code agent was created as a CLI tool that is run inside your C++ project directory. It will attempt to compile a set of C++ files and will ask ChatGPT to fix the code and provide explanations of what it changed. It is written in Rust and uses a job system written in C++ to launch specific jobs that are executed back in Rust. The three jobs that are used are a compile job, an output job, and a "fix code" job.

### Features

#### Git Safety Check

In order to prevent accidentally overwriting code, this program will check to see if there is a git repo and if so, checks for any uncommitted changes. This will force users to save their changes so they can rollback if something does not work. This can be disabled by using `--allow-dirty`. This feature was inspired by the `cargo clippy --fix` command which will do the same thing when applying Rust's Clippy fixes.

#### Tweak

After getting a response from ChatGPT, the user is presented with the new code and an option to "Accept", "Tweak", or "Quit/Cancel". If tweak is chosen, the new code will be opened in the user's `$EDITOR` where they can make changes to the new code before writing it to the file. This is especially useful to get rid of extra comments or print statements generated by ChatGPT.

#### Warnings

If `--fix-warnings` is provided, the compiler will look for warnings and errors instead of just errors and passing both to ChatGPT.

#### OpenAI Token

A users OpenAI token can be provided through an environment variable, a `.env` file in the project directory, a command line argument, or a .env file in the user's `$HOME` directory.

# Prompts Used

### Flowscript Prompt

```
You are writing an invented programming language called flowscript that is based on the dot language for describing graphs. Flowscript is used for defining the order of execution with a job system with predefined job names. Your objective is to write a job system to compile some C++ code and parse the results. To accomplish this, you have 2 job types that you can use "Compile" and "Output".

Flowscript begins with `diagraph {` and ends with a closing `}`.

In the middle you define both jobs and connections between them.
You must always include the job type called "input".

Other job names can be defined implicitly through connections.

For example:
`getEmail -> printEmail`
defines the "getEmail" job, the "printEmail" job and states that getEmail must be run before printEmail.

As a whole file it would be:
digraph {
  input;
  input -> getEmail;
  getEmail -> printEmail;
}

Please give me a flowscript file that runs the "Compile" job and then the "Output" job. Your response must start with "digraph" and end with "}". Do not provide an explanation or any code syntax highlighting blocks.
```

The prompt worked perfectly on the first try and also for all subsequent re-prompts after that. I did a version of one-shot prompting, but instead of mimicking earlier messages with the OpenAI API, I just included the example in the singular user prompt. The only error I ran into was the Compile and Output job being lowercase, I could have fixed this by adjusting the corresponding Rust enum to be renamed by the JSON parser but simply capitalizing the words in the prompt worked perfectly fine. I made sure to tell it that other job names are defined implicitly through connections so that the final code would be shorter and hopefully have less errors. I also made sure not to tell it anything about my Flowscript syntax that would be irrelevant to the task like if statements. "Your response must start with "digraph" and end with "}"." was the most helpful part in preventing an explanation.

### Fixing The Code

````json
[
  {
    "role": "system",
    "content": "You are an extremely smart assistant that helps with fixing c++ compiler errors  You will be given a json output of the clang compiler and then the original contents of the file. Please output a markdown response with the corrected source code and an explanation of what went wrong. Print the entire corrected source code file using the ```cpp tag, then an empty line then the explanation. You must give me the entire file, even if that means making the explanation shorter."
  },
  {
    "role": "user",
    "content": "Compiler Output: {COMPILER JSON OUTPUT}, Original File: {ORIGINAL FILE}"
  }
]
````

I left this prompt completely unchanged from the previous lab, except for asking for the entire file. I had an issue where the LLM was not providing the entire file updated which made fixing long files hard to do, but then I created an algorithm to insert a portion of the code into the original file. However, I kept asking it to use the full file because I found I was getting better results. I did not need to do any zero/few shot prompting to get it to work.

To parse the results I just created a function that would scan the lines of the response and pull out anything contained inside triple backticks. Everything else was joined into the explanation.

# Job System

![[diagram.png]]
The job system uses a 2-way FFI wrapper to send JSON data between the Rust program and the C++ job library. When running a job, the type of the job and it's JSON input are combined and passed to the worker thread where it will make an FFI call back to Rust with the input data and the job type and Rust will execute the job. This system made it easy for me to do the OpenAI api calls as a job, but the downside was that I had to rewrite the compiling job from the first lab. Another benefit to this system is that any struct that derives Serde's Serialize and Deserialize trait is able to be passed around in the Job system and remain strongly typed. The responses for a Job are weakly typed but still guaranteed to be valid JSON because to run a job in the system it must implement the Job trait, which I defined as:

```rust
fn run(&self) -> Result<Value>;
```

This restriction that resulted from the C++ system did not allow for any references or interior mutability within the Job structs but luckily I did not need that to create any of the jobs. It also meant that, since all of the job data was JSON strings, I had to clone a lot of data unnecessarily to move it in and out of C++ with C style string pointers.

# Jobs

### Compile Job

The compile job is responsible for taking a list of `PathBufs` (strings representing file locations), and compiling them together with g++. There is also an argument that determines if warnings should be looked for. The response is read from the console and parsed in to a `ClangOutputJson` data structure using Serde. Most of the fields are excluded from the compiler output since they are not needed for the LLM prompt. This is a pretty-print of the original g++ output.

```json
{
  "kind": "warning",
  "message": "#pragma once in main file",
  "children": [],
  "column-origin": 1,
  "locations": [
    {
      "caret": {
        "file": "./Code/lib/Logging.cpp",
        "line": 2,
        "display-column": 9,
        "byte-column": 9,
        "column": 9
      },
      "finish": {
        "file": "./Code/lib/Logging.cpp",
        "line": 2,
        "display-column": 12,
        "byte-column": 12,
        "column": 12
      }
    }
  ],
  "escape-source": false
}
```

This is the structure it is parsed into before it is passed to the output job:

```rust
struct ClangOutputJson {
    kind: ErrorKind,
    message: String,
    locations: Vec<LocationPair>,
}

struct LocationPair {
    caret: Location,
    finish: Option<Location>,
}

struct Location {
    file: PathBuf,
    line: i32,
    column: i32,
}

enum ErrorKind {
    Note,
    Error,
    Warning,
}
```

### Output Job

The output job's job is to take a vector of `ClangOutputJson` objects and turn it into a vector of `MappedJsonError`. This makes it easier for the LLM to understand the input when there it is only given the info it needs. This is the structure of the `MappedJsonError`:

```rust
pub struct MappedJsonError {
    column: i32,
    line: i32,
    pub filepath: PathBuf,
    pub message: String,
    snippet: String,
}
```

For everything except `snippet`, The fields are just rearranged and accessed. There is a separate function to generate the snippet which looks at the line number and reads the file path to get the 3 lines surrounding the error.

### FixCode Job

The "fix code" job takes the first element in the vector returned from the output job and provides it to an LLM (ChatGPT 4-Turbo in this case) to get back a code snippet and an explanation. The input for the job is:

```rust
pub struct FixCodeJob {
    pub model: Model, // ChatGpt, Mistral, or Orca
    pub output_json: MappedJsonError,
    pub file_contents: String,
}
```

and it returns:

```rust
pub struct FixCodeResult {
    pub code: String,
    pub explanation: String,
}
```

I use the crate `reqwest`'s blocking module to make the HTTP request to OpenAI. After the response is given, I run a function to extract out the code snippet and the explanation.

# Flowscript

My flowscript library is almost completely unchanged from the previous lab except for modifying the code that calls the Job system so that I can run rust jobs. The library is accessible from one method called `execute_flowscript`. Which takes a string input of the flowscript and a `serde_json::Value` to process it with. The flowscript execution is split up into 2 parts: first it extracts the definitions of the nodes and the connections, then it builds the graph by linking the Nodes as dynamic trait objects.
This is the grammar for my flowscript. Most of the features are still available like the if statements and multithreading support.

```c
WHITESPACE = _{ WHITE_SPACE }

program = {
    "digraph" ~ program_name? ~ "{" ~ program_body ~ "}" ~ ";"?
}

program_body = {
    line*
}

program_name = { (ALPHABETIC | "_")+ }

line = _{
    variable_def
  | connection_def
}

variable_def = {
    variable ~ attributes? ~ ";"
}

connection_def = {
    (variable ~ "->")+ ~ variable ~ attributes? ~ ";"
}

attributes = {
    "[" ~ attribute+ ~ "]"
}

attribute = ${
    attribute_name ~ "=" ~ quoted_attribute_value ~ " "? ~ ","?
}

quoted_attribute_value = _{ "\"" ~ attribute_value ~ "\"" }

attribute_value = @{ char* }
char = {
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "/" | "b" | "f" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{4})
}

attribute_name  = ${
    ALPHABETIC+
}

variable        = ${
    ALPHABETIC+
}
```

# Example Run Of Program

The following is a log of the execution for my entire "ExampleCode" folder. In my demo video I go through each folder individually but my program can also handling compiling them all at once as well.
The code in the "ExampleCode" folder is the version before any fixes have been applied.
The changes applied to the code (that we generated in this log) can be read in [this commit](https://github.com/drew-harris/fmc-final-test-code/commit/9fe4c746aec3e594cc60adc9b68e8315b561ad36).

---

Files: ["./multi-file/animal.cpp", "./multi-file/main.cpp", "./fix_warnings/main.cpp", "./simple_error/main.cpp", "./multi_errors/main.cpp", "./tweak/main.cpp"]

Just got new flowscript from chatgpt

Flowscript:

```d
digraph {
  input;
  input -> Compile;
  Compile -> Output;
}
```

Starting job system....
Creating a worker thread...
I only create one worker thread because I never have anything run more than once.

Compiling: ["./multi-file/animal.cpp", "./multi-file/main.cpp", "./fix_warnings/main.cpp", "./simple_error/main.cpp", "./multi_errors/main.cpp", "./tweak/main.cpp"]

Got errors:

```json
[
  {
    "column": 5,
    "line": 6,
    "filepath": "./multi-file/animal.cpp",
    "message": "'print' was not declared in this scope; did you mean 'printf'?",
    "snippet": "public:\n  void speak() {\n    print(\"hey im a animal\");\n  }\n};\n\n"
  },
  {
    "column": 5,
    "line": 13,
    "filepath": "./multi-file/animal.cpp",
    "message": "'print' was not declared in this scope; did you mean 'printf'?",
    "snippet": "public:\n  void speak() {\n    print(\"hey im a dog\");\n  };\n};\n\n"
  },
  {
    "column": 5,
    "line": 20,
    "filepath": "./multi-file/animal.cpp",
    "message": "'print' was not declared in this scope; did you mean 'printf'?",
    "snippet": "public:\n  void speak() {\n    print(\"hey im a cat\");\n  }\n};\n"
  },
  {
    "column": 5,
    "line": 6,
    "filepath": "./multi-file/./animal.cpp",
    "message": "'print' was not declared in this scope; did you mean 'printf'?",
    "snippet": "public:\n  void speak() {\n    print(\"hey im a animal\");\n  }\n};\n\n"
  },
  {
    "column": 5,
    "line": 13,
    "filepath": "./multi-file/./animal.cpp",
    "message": "'print' was not declared in this scope; did you mean 'printf'?",
    "snippet": "public:\n  void speak() {\n    print(\"hey im a dog\");\n  };\n};\n\n"
  },
  {
    "column": 5,
    "line": 20,
    "filepath": "./multi-file/./animal.cpp",
    "message": "'print' was not declared in this scope; did you mean 'printf'?",
    "snippet": "public:\n  void speak() {\n    print(\"hey im a cat\");\n  }\n};\n"
  },
  {
    "column": 10,
    "line": 9,
    "filepath": "./multi-file/main.cpp",
    "message": "'class Dog' has no member named 'speek'; did you mean 'speak'?",
    "snippet": "    // Speak twice\n    dog->speak();\n    dog->speek();\n\n    return 0;\n}\n"
  },
  {
    "column": 10,
    "line": 2,
    "filepath": "./simple_error/main.cpp",
    "message": "'cout' is not a member of 'std'",
    "snippet": "int main() {\n    std::cout << \"Hello World!\";\n    return 0;\n}\n"
  },
  {
    "column": 10,
    "line": 11,
    "filepath": "./multi_errors/main.cpp",
    "message": "'vector' is not a member of 'std'",
    "snippet": "\nint main() {\n    std::vector<Contact> contacts;\n    while (true) {\n        Contact newContact\n        std::cout << \"Enter contact name (or 'exit' to finish): \";\n"
  },
  {
    "column": 24,
    "line": 11,
    "filepath": "./multi_errors/main.cpp",
    "message": "expected primary-expression before '>' token",
    "snippet": "\nint main() {\n    std::vector<Contact> contacts;\n    while (true) {\n        Contact newContact\n        std::cout << \"Enter contact name (or 'exit' to finish): \";\n"
  },
  {
    "column": 26,
    "line": 11,
    "filepath": "./multi_errors/main.cpp",
    "message": "'contacts' was not declared in this scope; did you mean 'Contact'?",
    "snippet": "\nint main() {\n    std::vector<Contact> contacts;\n    while (true) {\n        Contact newContact\n        std::cout << \"Enter contact name (or 'exit' to finish): \";\n"
  },
  {
    "column": 9,
    "line": 14,
    "filepath": "./multi_errors/main.cpp",
    "message": "expected initializer before 'std'",
    "snippet": "    while (true) {\n        Contact newContact\n        std::cout << \"Enter contact name (or 'exit' to finish): \";\n        std::getline(std::cin, newContact.name);\n        if (newContact.name == \"exit\") {\n            break;\n"
  },
  {
    "column": 32,
    "line": 15,
    "filepath": "./multi_errors/main.cpp",
    "message": "'newContact' was not declared in this scope; did you mean 'Contact'?",
    "snippet": "        Contact newContact\n        std::cout << \"Enter contact name (or 'exit' to finish): \";\n        std::getline(std::cin, newContact.name);\n        if (newContact.name == \"exit\") {\n            break;\n        }\n"
  },
  {
    "column": 5,
    "line": 4,
    "filepath": "./tweak/main.cpp",
    "message": "'seifjosijeofj238h' was not declared in this scope",
    "snippet": "\nint main() {\n    seifjosijeofj238h\n    return 0;\n}\n"
  }
]
```

Asking ChatGPT to fix first error in the list using input:

FixCodeJob:

```json
{
  "model": "ChatGpt",
  "output_json": {
    "column": 5,
    "line": 6,
    "filepath": "./multi-file/animal.cpp",
    "message": "'print' was not declared in this scope; did you mean 'printf'?",
    "snippet": "public:\n  void speak() {
```
